package com.elytradev.concrete.resgen;

import com.elytradev.concrete.common.ConcreteLog;
import com.elytradev.concrete.reflect.accessor.Accessor;
import com.elytradev.concrete.reflect.accessor.Accessors;
import com.elytradev.concrete.reflect.invoker.Invoker;
import com.elytradev.concrete.reflect.invoker.Invokers;
import com.google.common.base.Charsets;
import com.google.common.collect.HashBiMap;
import com.google.common.collect.Maps;
import com.google.common.io.Resources;
import net.minecraft.block.Block;
import net.minecraft.client.Minecraft;
import net.minecraft.client.renderer.block.model.ModelResourceLocation;
import net.minecraft.client.resources.*;
import net.minecraft.init.Blocks;
import net.minecraft.init.Items;
import net.minecraft.item.Item;
import net.minecraft.util.ResourceLocation;
import net.minecraftforge.client.model.ModelLoader;
import net.minecraftforge.fml.client.FMLClientHandler;
import net.minecraftforge.fml.common.registry.RegistryDelegate;
import org.apache.commons.io.IOUtils;
import org.apache.commons.lang3.reflect.FieldUtils;
import org.apache.commons.lang3.tuple.Pair;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.lang.reflect.Field;
import java.util.*;

/**
 * Custom resource pack that is used when there's missing assets in your assets folder,
 * allows for auto genning common models like cubes and sprite based items.
 *
 * @see IResourceHolder for custom asset locations for items and blocks.
 */
public class ConcreteResourcePack extends AbstractResourcePack implements IResourceManagerReloadListener {

	private static Accessor<List<IResourcePack>> resourcePackList = Accessors.findField(FMLClientHandler.class, "resourcePackList");

	private static Accessor<File> resourcePackFile = Accessors.findField(AbstractResourcePack.class, "field_110597_b", "resourcePackFile");
	private static Accessor<IResourcePack> legacyPack = Accessors.findField(LegacyV2Adapter.class, "field_191383_a", "pack");
	private static Accessor<Map<String, FallbackResourceManager>> domainResourceManagers = Accessors.findField(SimpleReloadableResourceManager.class, "field_110548_a", "domainResourceManagers");
	private static Accessor<List<IResourcePack>> resourcePacks = Accessors.findField(FallbackResourceManager.class, "field_110540_a", "resourcePacks");

	private static Invoker hasResourceName = Invokers.findMethod(AbstractResourcePack.class, null, new String[]{"func_110593_b", "hasResourceName"}, String.class);
	private static Invoker getInputStreamByName = Invokers.findMethod(AbstractResourcePack.class, null, new String[]{"func_110591_a", "getInputStreamByName"}, String.class);

	private static String SIMPLE_BLOCK_MODEL;
	private static String SIMPLE_ITEM_MODEL;
	private static String SIMPLE_BLOCK_STATE;

	static {
		try {
			SIMPLE_BLOCK_MODEL = Resources.toString(ConcreteResourcePack.class.getResource("concreteblockmodel.json"), Charsets.UTF_8);
			SIMPLE_ITEM_MODEL = Resources.toString(ConcreteResourcePack.class.getResource("concreteitemmodel.json"), Charsets.UTF_8);
			SIMPLE_BLOCK_STATE = Resources.toString(ConcreteResourcePack.class.getResource("concreteblockstate.json"), Charsets.UTF_8);
		} catch (IOException e) {
			ConcreteLog.error("Caught IOException loading simple models, things will definitely not work.", e);
		}
	}

	public AbstractResourcePack realResourcePack;
	public String modID;
	public HashMap<String, String> cache;

	/**
	 * Create a ConcreteResourcePack for the specified mod, SimplePacks will auto gen simplemodels if you lack a blockstate or model file.
	 * If the applicable file exists it will simply default to it.
	 *
	 * @param modID the id of the mod you want a simple pack for.
	 */
	public ConcreteResourcePack(String modID) {
		super(getPackFileByModID(modID));
		this.modID = modID;
		this.cache = Maps.newHashMap();

		// Obtain the real resource pack generated by forge.

		IResourcePack realPack = FMLClientHandler.instance().getResourcePackFor(modID);
		if (realPack instanceof LegacyV2Adapter) {
			this.realResourcePack = (AbstractResourcePack) legacyPack.get(realPack);
		} else if (realPack instanceof AbstractResourcePack) {
			this.realResourcePack = (AbstractResourcePack) realPack;
		}

		if (realPack == null || this.realResourcePack == null) {
			throw new MissingRealpackException(modID);
		}

		//Add our pack as a default pack, use FMLClientHandler's field for this so we don't need to worry about obf names
		resourcePackList.get(FMLClientHandler.instance()).add(resourcePackList.get(FMLClientHandler.instance()).indexOf(realPack), this);

		// Confirms that our resourcepack is available as soon as possible to prevent missing resource errors.
		if (Minecraft.getMinecraft().getResourceManager() instanceof SimpleReloadableResourceManager) {
			SimpleReloadableResourceManager resourceManager = (SimpleReloadableResourceManager) Minecraft.getMinecraft().getResourceManager();
			resourceManager.registerReloadListener(this);

			// Forces this resource pack to be loaded early on. FML already did it's initial registration so we need to bypass that.
			FallbackResourceManager domainManager = domainResourceManagers.get(resourceManager).get(modID);
			resourcePacks.get(domainManager).add(resourcePacks.get(domainManager).indexOf(realPack), this);
		}
	}

	private static File getPackFileByModID(String modID) {
		IResourcePack pack = FMLClientHandler.instance().getResourcePackFor(modID);
		if (pack instanceof LegacyV2Adapter) {
			return resourcePackFile.get(legacyPack.get(pack));
		} else if (pack instanceof AbstractResourcePack) {
			return resourcePackFile.get(pack);
		}
		return null;
	}

	@Override
	protected InputStream getInputStreamByName(String name) throws IOException {
		// Check if we've already cached a model for this name.
		if (cache.containsKey(name)) {
			ConcreteLog.debug("ConcreteResourcePack was asked to obtain: {} using cache.", name);
			return IOUtils.toInputStream(cache.get(name));
		}

		// Return a stream corresponding to a matching location.
		ConcreteLog.debug("ConcreteResourcePack was asked to obtain: {}", name);
		if (isLocation(name, "/blockstates/")) {
			return IOUtils.toInputStream(generateBlockState(name));
		} else if (isLocation(name, "/models/block/")) {
			return IOUtils.toInputStream(generateBlockModel(name));
		} else if (isLocation(name, "/models/item/")) {
			return IOUtils.toInputStream(generateItemModel(name));
		}


		// Use the real pack in the event that we're asked for a resource we don't have.
		// Most notable example being pack.mcmeta.
		return (InputStream) getInputStreamByName.invoke(realResourcePack, name);
	}


	@Override
	protected boolean hasResourceName(String name) {
		if (isLocation(name, "/blockstates/")) {
			ConcreteLog.debug("Location was provided {}, matched blockstate check.", name);
			return true;
		}
		if (isLocation(name, "/models/block/")) {
			ConcreteLog.debug("Location was provided {}, matched block model check.", name);
			return true;
		}
		if (isLocation(name, "/models/item/")) {
			ConcreteLog.debug("Location was provided {}, matched item model check.", name);
			return true;
		}
		return false;
	}

	@Override
	public Set<String> getResourceDomains() {
		return realResourcePack.getResourceDomains();
	}

	/**
	 * Auto clears the cache on a resource manager reload.
	 *
	 * @param iResourceManager
	 */
	@Override
	public void onResourceManagerReload(IResourceManager iResourceManager) {
		cache.clear();
	}

	/**
	 * Converts a name given by AbstractResourcePack back into a ResourceLocation.
	 *
	 * @param name provided by AbstractResourcePack
	 * @return a ResourceLocation matching the given data.
	 */
	private static ResourceLocation nameToLocation(String name) {
		name = name.substring(name.indexOf("/") + 1);
		String domain = name.substring(0, name.indexOf("/"));
		String path = name.substring(name.indexOf("/") + 1);

		ConcreteLog.debug("Converted {} to {}", name, new ResourceLocation(domain, path));
		return new ResourceLocation(domain, path);
	}

	/**
	 * Used in place of an Accessor due to an error with static fields.
	 *
	 * @return the value of ModelLoader.customModels
	 */
	private static Map<Pair<RegistryDelegate<Item>, Integer>, ModelResourceLocation> getCustomModels() {
		try {
			Field field = ModelLoader.class.getDeclaredField("customModels");
			return (Map<Pair<RegistryDelegate<Item>, Integer>, ModelResourceLocation>) FieldUtils.readStaticField(field, true);
		} catch (Exception e) {
			ConcreteLog.error("Caught exception getting customModels from the model loader, ", e);
		}

		return Collections.emptyMap();
	}

	/**
	 * Generates a string of JSON representing a blockstate for the given location.
	 */
	private String generateBlockState(String name) {
		String blockID = name.substring(name.lastIndexOf("/") + 1, name.lastIndexOf("."));
		Block blockFromLocation = Block.getBlockFromName(modID + ":" + blockID);
		String modelLocation = modID + ":" + blockID;
		if (blockFromLocation instanceof IResourceHolder) {
			modelLocation = ((IResourceHolder) blockFromLocation).getResource(EnumResourceType.MODEL, 0).toString();
			modelLocation = modelLocation.substring(modelLocation.lastIndexOf("/" + 1));
			modelLocation = modID + ":" + modelLocation;
		}

		String simpleBlockState = SIMPLE_BLOCK_STATE;
		simpleBlockState = simpleBlockState.replaceAll("%MDL%", modelLocation);
		cache.put(name, simpleBlockState);
		return simpleBlockState;
	}

	/**
	 * Generates a string of JSON representing a block model for the given location.
	 */
	private String generateBlockModel(String name) {
		String blockID = name.substring(name.lastIndexOf("/") + 1, name.lastIndexOf("."));
		Block blockFromLocation = Block.getBlockFromName(modID + ":" + blockID);
		String textureLocation = modID + ":blocks/" + blockID;
		Integer meta = getMetaFromName(name);

		if (blockFromLocation instanceof IResourceHolder) {
			textureLocation = ((IResourceHolder) blockFromLocation).getResource(EnumResourceType.TEXTURE, meta).toString();
		}

		String simpleBlockJSON = SIMPLE_BLOCK_MODEL;
		simpleBlockJSON = simpleBlockJSON.replaceAll("%ALL%", textureLocation);
		cache.put(name, simpleBlockJSON);
		return simpleBlockJSON;
	}

	/**
	 * Generates a string of JSON representing an item model for the given location.
	 */
	private String generateItemModel(String name) {
		String itemID = name.substring(name.lastIndexOf("/") + 1, name.lastIndexOf("."));
		Item itemFromLocation = getItem(name);
		String textureLocation = modID + ":items/" + itemID;
		Integer meta = getMetaFromName(name);

		if (itemFromLocation instanceof IResourceHolder) {
			textureLocation = ((IResourceHolder) itemFromLocation).getResource(EnumResourceType.TEXTURE, meta).toString();
		}

		// Return a block model file if this is an ItemBlock.
		if (Block.getBlockFromItem(itemFromLocation) != Blocks.AIR) {
			if (itemFromLocation.getRegistryName().getResourcePath().equals(itemID)) {
				try {
					String blockName = name.replace("/item/", "/block/");
					// Checks if we can use an existing block model or if we need to gen our own.
					if ((boolean) hasResourceName.invoke(realResourcePack, blockName)) {
						cache.put(name, IOUtils.toString((InputStream) getInputStreamByName.invoke(realResourcePack, blockName)));
					} else {
						cache.put(name, IOUtils.toString(getInputStreamByName(blockName)));
					}
				} catch (IOException e) {
					ConcreteLog.error("Failed to get item model for {}", name);
				}
			} else {
				String simpleBlockModel = SIMPLE_BLOCK_MODEL;
				simpleBlockModel = simpleBlockModel.replaceAll("%ALL%", textureLocation);
				cache.put(name, simpleBlockModel);
			}
			return cache.get(name);
		}

		String simpleItemModel = SIMPLE_ITEM_MODEL;
		simpleItemModel = simpleItemModel.replaceAll("%L0%", textureLocation);
		cache.put(name, simpleItemModel);
		return simpleItemModel;
	}

	/**
	 * Gets an item based on the name given by AbstractResourcePack.
	 *
	 * @param name the name provided by AbstractResourcePack
	 * @return the Item corresponding to the given name.
	 */
	private Item getItem(String name) {
		String itemID = name.substring(name.lastIndexOf("/") + 1, name.lastIndexOf("."));
		if (Item.getByNameOrId(modID + ":" + itemID) != null) {
			return Item.getByNameOrId(modID + ":" + itemID);
		} else {
			ResourceLocation location = nameToLocation(name);
			try {
				HashBiMap<Pair<RegistryDelegate<Item>, Integer>, ModelResourceLocation> customModelsMap = HashBiMap.create(getCustomModels());
				String resourcePath = location.getResourcePath();
				resourcePath = resourcePath.substring(resourcePath.lastIndexOf("/") + 1);
				resourcePath = resourcePath.substring(0, resourcePath.lastIndexOf("."));
				String domain = location.getResourceDomain();
				location = new ModelResourceLocation(domain + ":" + resourcePath, isLocation(name, "/models/item/") ? "inventory" : "normal");
				if (customModelsMap.inverse().containsKey(location))
					return customModelsMap.inverse().get(location).getLeft().get();
			} catch (Exception e) {
				ConcreteLog.error("Failed to get item from ResourceLocation", e);
			}
			return Items.AIR;
		}
	}

	/**
	 * Attempt to get metadata value from ModelLoader to account for custom mesh locations, returns 0 if none were found.
	 *
	 * @param name name provided by getInputStreamByName
	 * @return metadata if found, 0 if none.
	 */
	private Integer getMetaFromName(String name) {
		ResourceLocation location = nameToLocation(name);
		try {
			HashBiMap<Pair<RegistryDelegate<Item>, Integer>, ModelResourceLocation> customModelsMap = HashBiMap.create(getCustomModels());
			String resourcePath = location.getResourcePath();
			resourcePath = resourcePath.substring(resourcePath.lastIndexOf("/") + 1);
			resourcePath = resourcePath.substring(0, resourcePath.lastIndexOf("."));
			String domain = location.getResourceDomain();
			location = new ModelResourceLocation(domain + ":" + resourcePath, isLocation(name, "/models/item/") ? "inventory" : "normal");
			if (customModelsMap.inverse().containsKey(location))
				return customModelsMap.inverse().get(location).getRight();
		} catch (Exception e) {
			ConcreteLog.error("Failed to get metadata from name", e);
		}
		return 0;
	}

	/**
	 * Check if the place provided matches the location validation.
	 *
	 * @param place      The place to check.
	 * @param validation The validation to use.
	 * @return true if matches, false otherwise.
	 */
	private boolean isLocation(String place, String validation) {
		return place.startsWith(("assets/" + modID + validation)) && place.endsWith(".json");
	}

}
